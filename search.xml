<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git的简单用法]]></title>
    <url>%2F2018%2F04%2F06%2Fgit-command%2F</url>
    <content type="text"><![CDATA[简单记录一些我常用的git命令，和我对他们的理解。Cheat Sheet]]></content>
  </entry>
  <entry>
    <title><![CDATA[React Plugins For Sublime Text3]]></title>
    <url>%2F2018%2F03%2F11%2Freact-plugins-for-sublime-text3%2F</url>
    <content type="text"><![CDATA[This post summarizes some useful plugins for React developer who are using Sublime text3. Sublime React PluginsReact ES6 Snippetscdm→ componentDidMount: fn() { ... } cdup→ componentDidUpdate: fn(pp, ps) { ... } cs→ import cx from &apos;classnames&apos;; cwm→ componentWillMount: fn() { ... } cwr→ componentWillReceiveProps: fn(np) { ... } cwu→ componentWillUpdate: fn(np, ns) { ... } cwun→ componentWillUnmount: fn() { ... } cx→ cx({ ... }) fdn→ React.findDOMNode(...) fup→ forceUpdate(...) gdp→ static defaultProps = { ... } gis→ getInitialState: fn() { return {...} } ism→ isMounted() props→ this.props. pt→ propTypes { ... } rcc→ component skeleton refs→ this.refs. ren→ render: fn() { return ... } rpc→ pure render component skeleton rrc→ redux component skeleton scu→ shouldComponentUpdate: fn(np, ns) { ... } sst→ this.setState({ ... }) state→ this.state. sublime-jsfmt { // autoformat on save &quot;autoformat&quot;: false, // array of extensions for autoformat &quot;extensions&quot;: [&quot;js&quot;, &quot;sublime-settings&quot;], // options for jsfmt &quot;options&quot;: { &quot;preset&quot;: &quot;jquery&quot;, &quot;indent&quot;: { &quot;value&quot;: &quot; &quot; }, // plugins included &quot;plugins&quot;: [ // &quot;esformatter-quotes&quot;, // &quot;esformatter-semicolons&quot;, // &quot;esformatter-braces&quot;, // &quot;esformatter-dot-notation&quot; ] }, &quot;options-JSON&quot;: { &quot;plugins&quot;: [ &quot;esformatter-quotes&quot; ], &quot;quotes&quot;: { &quot;type&quot;: &quot;double&quot; } }, &quot;alert-errors&quot;: true, // path to nodejs &quot;node-path&quot;: &quot;node&quot;, // if true it will format the whole file even if you have a selection active &quot;ignore-selection&quot;: false } babel-sublimeSetting as the default syntaxTo set it as the default syntax for a particular extension: Open a file with that extension,Select View from the menu,Then Syntax -&gt; Open all with current extension as… -&gt; Babel -&gt; JavaScript (Babel).Repeat this for each extension (e.g.: .js and .jsx). Emmet]]></content>
      <categories>
        <category>plugins</category>
        <category>sublime text3</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>sublime text3</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS504 Note]]></title>
    <url>%2F2018%2F03%2F03%2Fcs504-note%2F</url>
    <content type="text"><![CDATA[This is a Note for CS504. Spring Boot Almost 0 manual configuration Fast development and deployment Starter POM VS Individual Dependencies Built-in application metrics, health check, and external configurations Absolutely no code generation and no requirement for XML configuration Code StructureApplication.java Domain Customer.java CustomerRepository.java Service CustomerService.java Web CustomerController.java Java Persistence API(JPA)JavaEE: Hibernate Spring Data]]></content>
      <categories>
        <category>note</category>
        <category>cs504</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS503 Note]]></title>
    <url>%2F2018%2F03%2F03%2Fcs503-note%2F</url>
    <content type="text"><![CDATA[This is a Note for CS503. 理论课Front End Web 1.0: 静态HTML -&gt; Javascript &amp; CSS; CGI(common gateway interface) 有程序操作，返回输出给浏览器；每个request需要一个程序处理，无法处理并发; Servlet: 绑定Html和程序，通过程序改变网页内容=JAVA + HTML; ASP，JSP，PHP；结合HTML和程序. JSP = HTML + JAVA; 支持语法检查; Ajax&amp;JQuery: 异步加载；MVC: 设计模式;(前端后端需要合作，不能分离工作) Node: Client-side MVC; 分离前后端，只传输数据 -&gt; Angular 和 React出现 React: 1.One way data flow;2.Vitual DOM;3.JSX Node/Express多线程切换context的代价大;单线程可以避免这种消耗; Node是在server端运行javascript的环境，Express是一个简化搭建服务器的框架。 Express 中间件的思想，连接不同组件。 NoSQL Key-value Store: Redis,Dynamo Document-based Store: MongoDB Column-based Store: BigTable, HBase, Cassandra CAP Theorem: Consistensy, Availability, Patition-tolerance MongoDBDocument-oriented Database Map nicely to programming language data types Enbeded documents reduce the need of joins Dynamic schema Store in Bson files MongoDB -&gt; databases -&gt; collection -&gt; documents PROs: Simple use/Faster/Easier and faster integrationCONs: Cannot be used for heavy and complex transactions systems. Using pyMongo to connect python with MongoDB, manage connections automatically. Message Queue An application framework for sending and receiving messages A way to communicate between applications A way to decouple components A way to offload work Message Queue Protocol AMQP - RabbitMQ STOMP - ActiveMQ XMPP Using pika to connect python with RabbitMQ(CloudAMQP). SOA(Service-oriented Architecture)PROs: Isolation/Ownership/ScalabilityCONs: Complexity/Latency/Test effort/DevOp, on-call API design Web Service APIS: REST/JSON-RPC/XML-RPC Library-based APIS: Javascript Class-based API: Java API, Android API OS Functions and Roytines: File system Hardware APIS RPC(Action oriented) REST(Resource oriented) Using python-jsonrpc in python to create RPC functions Good API: Easy to learn and use with documentaion Hard to misuse Easy to read and maintain Sufficient powerful to meet the requirement Easy to extend API should do one thing and do it well API should be as small as possible Implementation should not impact API(eg.Name) Minimize accessibility of everything Names Matter Documentaion Matters Consider performence consequence of API design decisions Coexist peacefully with platform Web ScrapingApplication Data source Indexer &amp; Crawler Test Tools: XPath Regular Expression Beautiful Soup Basic flow Request web server to retrieve HTML -&gt; requests Parse the HTML into structured data -&gt; lxml Use XPath or Regex to extract infomation -&gt; lxml, re Store the information -&gt; pymongo Integration with RabbitMQ Store scraping tasks temporarily Make scraper running continuously Let scaper feed itself Coordinate multiple scrapers working together Avoid Blocking Limit scraping rate Follow website’s robot.txt User Agent Proxy TOR(The Onion Router) NLP(Natural Language Processing)TF-IDF(Term Frequency-Inverse Document frequency) Machine Leaning Basics Supervised Learning Unsupervised Learning Reinforcement Learning Classification Regression Similarity Ranking Sequence Prediction TensorFlow A deep learning library open-sourced by Google TensorFlow provides primitives for defining functions on tensors and automatically computing their derivatives. 实践课Create React Appsudo npm install -g create-react-appcreate-react-app tap-news npm start Express Generatervar this 变量 {} []apply cookie浏览器端保存信息 email: indexpassowrd: bcrypt saltpassportmongoosevalidator 判断email Auth0 pickle 时间衰减模型 选择 p=(1-a)*p+a 没有选择 p=(1-a)*p]]></content>
      <categories>
        <category>note</category>
        <category>cs503</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How To Use Docker]]></title>
    <url>%2F2018%2F03%2F02%2Fhow-to-use-docker%2F</url>
    <content type="text"><![CDATA[This post include information of installation and simple useage of docker. Install dockerFor UbuntuDocker needs Ubuntu system which version is higher then 3.10, so first check that: uname -r Using shell sciprt to install: wget -qO- https://get.docker.com/ | sh For macOSUsing Homebrew install Docker: brew cask install docker For All Linux$ #[sudo apt-get remove docker docker-engine docker.io] $ sudo apt-get update $ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo apt-key fingerprint 0EBFCD88 result should be like this: pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid Docker Release (CE deb) &lt;docker@docker.com&gt; sub 4096R/F273FCD8 2017-02-22 if correct, then: $ sudo add-apt-repository \ &quot;deb [arch=amd64] https:// download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; $ sudo apt-get update $ sudo apt-get install docker-ce # Test $ sudo docker run hello-world For other system see Docker installDocker commandsAll Commands with explanation here]]></content>
      <categories>
        <category>tutorial</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pip Install LXML Error]]></title>
    <url>%2F2018%2F02%2F09%2Ffail-to-install-lxml-using-pip%2F</url>
    <content type="text"><![CDATA[When I running sudo pip install lxml, a error occur says I need to install libxml2 and libxslt. After looking up online, I found the resolution for that problem. Install lxml using pipWhere to get it1. linuxpython 2sudo apt-get install python-lxml python 3sudo apt-get install python3-lxml 2. Macsudo port install py27-lxml Requirementssudo apt-get install libxml2-dev libxslt-dev python-dev For Debian based systems, it should be enough to install the known build dependencies of the provided lxml package, e.g. sudo apt-get build-dep python3-lxml Installationsudo pip install lxml Reference Installing lxml]]></content>
      <categories>
        <category>error</category>
        <category>pip</category>
        <category>lxml</category>
      </categories>
      <tags>
        <tag>install</tag>
        <tag>lxml</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建静态博客]]></title>
    <url>%2F2018%2F01%2F10%2Fbuild-blog-by-hexo%2F</url>
    <content type="text"><![CDATA[之前作者一直使用jekyll建立博客，被安利了hexo之后进行了尝试，发现果然要比jekyll好用简单的多，因此也把转移的过程简单写了一份攻略，供大家参考。 使用Hexo建立博客之前有使用jekyll建立过博客，过程比较麻烦，而且因为jekyll使用的是ruby，而我对ruby不是很了解，所以修改起来很麻烦。hexo同样是建立静态博客的程序，但是因为其用的是nodejs所以安装和修改都要比jekyll简单。 安装HexoHexo的安装需要nodejs的支持，所以首先要安装nodejs。在有了nodejs之后，就可以用npm命令了。使用npm install hexo-cli -g命令安装hexo，-g参数是全局安装。使用hexo init blog初始化目录。命令结束后产生一个叫blog的目录，进入目录后运行npm install，这个命令会根据package.json文件自动安装依赖，非常的容易，这也是nodejs很火的一个原因。运行hexo g[enerate]会生成一个public的文件，这个文件包含了网页的所有内容，类似c语言的编译。完成后运行hexo s[erver]就可以运行网页了。运行后可以从localhost:4000端口查看。可以看到自带的网页布局就已经很好看了。 模版尽管自带的网页就已经不错了，但是想要更漂亮还是需要模版。我选择了很有名的next模版，界面简单，功能很全而且说明清晰。hexo和jekyll又一个很大的区别就是jekyll不同的模版配置麻烦，但是对hexo来说，如果hexo是人的话，那么模版就像衣服一样，可以随便换。只需要在配置文件里做一下小小的更改就可以。讲模版（主题）下载到themes文件下面，直接修改_config.yml就可以了。 部署hexo d命令可以用来部署，但是需要提前安装插件npm install hexo-deployer-git --save。–save表示将这个插件加入package.json文件。之后在配置中添加 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 如果github主页已经关联了域名的话需要将CNAME放在resource文件夹下，并在CNAME中添加域名。 参考文档Hexo中文文档Hexo主页如何搭建一个独立博客——简明Github Pages与Hexo教程Next使用文档]]></content>
      <categories>
        <category>tutorial</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Make编写MakeFile]]></title>
    <url>%2F2017%2F12%2F10%2Fhow-to-use-makefile%2F</url>
    <content type="text"><![CDATA[本文通过一些例子来说明一些Make和Makefile的基本使用方法和一些坑，作者也是小白，大神就不要凑热闹了。 MakeFileIntroduction of MakeFile and Make file: http://mrbook.org/blog/tutorials/make/ How to write MakeFile: http://www.cnblogs.com/lgz24/archive/2011/03/21/1990090.html ExamplesExemple1: 1234cc = g++CFLAGS = -std=c++11 -gmemsim:main.cpp $(cc) $(CFLAGS) main.cpp -o memsim Example2: 12345678910cc = g++CFLAGS = -std=c++11 -g m:main.cpp Test_class.o $(cc) $(CFLAGS) main.cpp Test_class.o -o memsimanyname.o:Test_class.cpp Test_class.h $(cc) -c Test_class.cpp Test_class.h #Test_class.cpp Test_class.h 自动生成 Test_class.o #也可以不加Test_class.hclean: rm *o memsim Example3: 标签方法(Using label like “Cache Tools Block “ in this case) 12345678910111213141516171819202122232425262728cc = g++CFLAGS = -std=c++11 -g# -g 参数表示可以用来GDB调试memsim:cacheSimulator.cpp Cache Tools Block#Cache Tools Block 表示依赖关系；make将会从下方中找代码并执行 echo --------memsim1-------- $(cc) $(CFLAGS) cacheSimulator.cpp Cache.o Tools.o Block.o -o memsim echo --------memsim2--------Cache:Cache.cpp Cache.h Block echo --------cache1-------- $(cc) $(CFLAGS) -c Cache.cpp Cache.h Block.o # 如果没有-c会去找 main 但是因为没有main所以会报错 echo --------cache2--------Tools:Tools.h Tools.cpp echo --------tools1-------- $(cc) $(CFLAGS) -c Tools.h Tools.cpp echo --------tools2--------Block:Block.h Block.cpp echo --------block1-------- $(cc) $(CFLAGS) -c Block.h Block.cpp echo --------block2--------clean: echo --------remove executable program-------- /bin/rm -rf *.o *.h.gch memsim Example4： .o文件方法(Using name like “cache.o”) 12345678910111213141516171819memsim:cacheSimulator.cpp Cache.o Tools.o Block.o echo --------memsim1-------- $(cc) $(CFLAGS) cacheSimulator.cpp Cache.o Tools.o Block.o -o memsim echo --------memsim3--------Cache.o:Cache.cpp Cache.h Block.o echo --------cache.o1-------- $(cc) $(CFLAGS) -c Cache.cpp Cache.h Block.o echo --------cache.o2--------Tools.o:Tools.h Tools.cpp echo --------tools.o1-------- $(cc) $(CFLAGS) -c Tools.h Tools.cpp echo --------tools.o2--------Block.o:Block.h Block.cpp echo --------block.o1-------- $(cc) $(CFLAGS) -c Block.h Block.cpp echo --------block.o2-------- Example5: 直接依赖(Directly show the dependency) 12345678910111213cc = g++CFLAGS = -std=c++11 -gmemsim:cacheSimulator.cpp Cache.o Tools.o Block.o echo --------memsim1-------- $(cc) $(CFLAGS) cacheSimulator.cpp Cache.o Tools.o Block.o -o memsim echo --------memsim3--------Cache.o:Cache.cpp Cache.h Block.oTools.o:Tools.h Tools.cppBlock.o:Block.h Block.cpp Example6: only with xxx.h cannot generate xxx.o but can use xxx.h directly instead even at least, we can just gennerate the exe file without a lot of files like: 12345678910cc = g++CFLAGS = -std=c++11 -gmemsim:cacheSimulator.cpp Cache.o Tools.o# 在这里，如果不用Cache.o将会报错 make根据这一行寻找依赖 .o文件将会自动寻找文件的依赖 echo --------compiling cacheSimulator.cpp-------- $(cc) $(CFLAGS) cacheSimulator.cpp Cache.o Tools.o -o memsimclean: echo --------remove executable program-------- /bin/rm -rf *.o *.gch memsim 3.Copy from above link0.1 关于程序的编译和链接 在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是 OBJ文件）。 链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File. 好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。 Makefile 介绍 -——————————————————————————- make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8 个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。 只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 1.1 Makefile的规则 在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。 target … : prerequisites … command … … target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites就是，要生成那个target所需要的文件或是目标。 command也就是make需要执行的命令。（任意的Shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在 command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是 Makefile的规则。也就是Makefile中最核心的内容。 说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：） 1.2 一个示例 正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 反斜杠（\）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile” 的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 “make clean”就可以了。 在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 1.3 make是如何工作的 在默认的方式下，也就是我们只输入make命令。那么， make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程） 当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。 通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。 于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以 edit也会被重新链接了（详见edit目标文件后定义的命令）。 而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。 1.4 makefile中使用变量 在上面的例子中，先让我们看看edit的规则： ​ edit : main.o kbd.o command.o display.o \ ​ insert.o search.o files.o utils.o ​ cc -o edit main.o kbd.o command.o display.o \ ​ insert.o search.o files.o utils.o 我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在 clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成 C语言中的宏可能会更好。 比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义： ​ objects = main.o kbd.o command.o display.o \ ​ insert.o search.o files.o utils.o 于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子： ​ objects = main.o kbd.o command.o display.o \ ​ insert.o search.o files.o utils.o ​ edit : $(objects) ​ cc -o edit $(objects) ​ main.o : main.c defs.h ​ cc -c main.c ​ kbd.o : kbd.c defs.h command.h ​ cc -c kbd.c ​ command.o : command.c defs.h command.h ​ cc -c command.c ​ display.o : display.c defs.h buffer.h ​ cc -c display.c ​ insert.o : insert.c defs.h buffer.h ​ cc -c insert.c ​ search.o : search.c defs.h buffer.h ​ cc -c search.c ​ files.o : files.c defs.h buffer.h command.h ​ cc -c files.c ​ utils.o : utils.c defs.h ​ cc -c utils.c ​ clean : ​ rm edit $(objects) 于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。 关于变量更多的话题，我会在后续给你一一道来。 1.5 让make自动推导 GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么 whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。 ​ objects = main.o kbd.o command.o display.o \ ​ insert.o search.o files.o utils.o ​ edit : $(objects) ​ cc -o edit $(objects) ​ main.o : defs.h ​ kbd.o : defs.h command.h ​ command.o : defs.h command.h ​ display.o : defs.h buffer.h ​ insert.o : defs.h buffer.h ​ search.o : defs.h buffer.h ​ files.o : defs.h buffer.h command.h ​ utils.o : defs.h ​ .PHONY : clean ​ clean : ​ rm edit $(objects) 这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。 关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。 1.6 另类风格的makefile 即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。 ​ objects = main.o kbd.o command.o display.o \ ​ insert.o search.o files.o utils.o ​ edit : $(objects) ​ cc -o edit $(objects) ​ $(objects) : defs.h ​ kbd.o command.o files.o : command.h ​ display.o insert.o search.o files.o : buffer.h ​ .PHONY : clean ​ clean : ​ rm edit $(objects) 这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。 1.7 清空目标文件的规则 每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是： ​ clean: ​ rm edit $(objects) 更为稳健的做法是： ​ .PHONY : clean ​ clean : ​ -rm edit $(objects) 前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。 上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。 2 Makefile 总述 2.1 Makefile里有什么？ Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定 Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。 最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 2.2Makefile的文件名 默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。 当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“- f”和“–file”参数，如：make -f Make.Linux或make –file Make.AIX。 2.3 引用其它的Makefile 在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： include filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符） 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句： ​ include foo.make *.mk $(bar) 等价于： ​ include foo.make a.mk b.mk c.mk e.mk f.mk make 命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。 如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在 include前加一个减号“-”。如： -include 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。 2.4 环境变量 MAKEFILES 如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。 但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的 Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 2.5 make的工作方式 GNU的make工作时的执行步骤入下：（想来其它的make也是类似） 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 1-5 步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。 3 Makefile书写规则 -——————————————————————————- 规则包含两个部分，一个是依赖关系，一个是生成目标的方法。 在 Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。 好了，还是让我们来看一看如何书写规则。 3.1 规则举例 foo.o : foo.c defs.h # foo模块 ​ cc -c -g foo.c 看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事： 文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。 如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件） 3.2 规则的语法 ​ targets : prerequisites ​ command ​ … 或是这样： ​ targets : prerequisites ; command ​ command ​ … targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。 command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上） prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。 如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。 一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。 3.3 在规则中使用通配符 如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[…]”。这是和Unix的B-Shell是相同的。 波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而 “~hchen /test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。 通配符代替了你一系列的文件，如“.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“”，那么可以用转义字符“\”，如“*”来表示真实的“*”字符，而不是任意长度的字符串。 好吧，还是先来看几个例子吧： ​ clean: ​ rm -f *.o 上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。 ​ print: *.c ​ lpr -p $? ​ touch print 上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。 ​ objects = *.o 上面这个例子，表示了，通符同样可以用在变量中。并不是说[.o]会展开，不！objects的值就是“.o”。Makefile中的变量其实就是 C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样： ​ objects := $(wildcard *.o) 这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。 3.4 文件搜寻 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。 Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 VPATH = src:../headers 上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方） 另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个 VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种： vpath &lt; pattern&gt; &lt; directories&gt; 为符合模式 &lt; pattern&gt;的文件指定搜索目录 &lt; directories&gt;。 vpath &lt; pattern&gt; 清除符合模式 &lt; pattern&gt;的文件的搜索目录。 vpath 清除所有已被设置好了的文件搜索目录。 vapth 使用方法中的 &lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。 &lt; pattern&gt;指定了要搜索的文件集，而 &lt; directories&gt;则指定了的文件集的搜索的目录。例如： ​ vpath %.h ../headers 该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话） 我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的 &lt; pattern&gt;，或是被重复了的 &lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如： ​ vpath %.c foo ​ vpath % blish ​ vpath %.c bar 其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。 ​ vpath %.c foo:bar ​ vpath % blish 而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。 3.5 伪目标 最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”， ​ clean: ​ rm *.o temp 正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标） 因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。 当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 ​ .PHONY : clean 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写： ​ .PHONY: clean ​ clean: ​ rm *.o temp 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性： ​ all : prog1 prog2 prog3 ​ .PHONY : all ​ prog1 : prog1.o utils.o ​ cc -o prog1 prog1.o utils.o ​ prog2 : prog2.o ​ cc -o prog2 prog2.o ​ prog3 : prog3.o sort.o utils.o ​ cc -o prog3 prog3.o sort.o utils.o 我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 “.PHONY : all”声明了“all”这个目标为“伪目标”。 随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子： ​ .PHONY: cleanall cleanobj cleandiff ​ cleanall : cleanobj cleandiff ​ rm program ​ cleanobj : ​ rm *.o ​ cleandiff : ​ rm *.diff “make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的 3.6 多目标 Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。 ​ bigoutput littleoutput : text.g ​ generate text.g -$(subst output,,$@) &gt; $@ ​ 上述规则等价于： ​ bigoutput : text.g ​ generate text.g -big &gt; bigoutput ​ littleoutput : text.g ​ generate text.g -little &gt; littleoutput 其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。 3.7 静态模式 静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： : : …targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。 target-parrtern是指明了targets的模式，也就是的目标集模式。 prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。 这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的 定义成“%.c”，意思是对 所形成的目标集进行二次定义，其计算方法是，取 模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。 所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。 看一个例子： ​ objects = foo.o bar.o ​ all: $(objects) ​ $(objects): %.o: %.c ​ $(CC) -c $(CFLAGS) $ &lt; -o $@ 上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$ &lt;”和“$@”则是自动化变量，“$ &lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则： ​ foo.o : foo.c ​ $(CC) -c $(CFLAGS) foo.c -o foo.o ​ bar.o : bar.c ​ $(CC) -c $(CFLAGS) bar.c -o bar.o 试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子： ​ files = foo.elc bar.o lose.o ​ $(filter %.o,$(files)): %.o: %.c ​ $(CC) -c $(CFLAGS) $ &lt; -o $@ ​ $(filter %.elc,$(files)): %.elc: %.el ​ emacs -f batch-byte-compile $ &lt; $(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。 3.8 自动生成依赖性 在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是： ​ main.o : main.c defs.h 但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令： ​ cc -M main.c 其输出是： ​ main.o : main.c defs.h 于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。 gcc -M main.c的输出是： ​ main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \ ​ /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \ ​ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \ ​ /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \ ​ /usr/include/bits/sched.h /usr/include/libio.h \ ​ /usr/include/_G_config.h /usr/include/wchar.h \ ​ /usr/include/bits/wchar.h /usr/include/gconv.h \ ​ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \ ​ /usr/include/bits/stdio_lim.h gcc -MM main.c的输出则是： ​ main.o: main.c defs.h 那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile 自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。 于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。 这里，我们给出了一个模式规则来产生[.d]文件： ​ %.d: %.c ​ @set -e; rm -f $@; \ ​ $(CC) -M $(CPPFLAGS) $ &lt; &gt; $@.$$$$; \ ​ sed ‘s,($).o[ :],\1.o $@ : ,g’ &lt; $@.$$$$ &gt; $@; \ ​ rm -f $@.$$$$ 这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$ &lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是 “name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。 总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： ​ main.o : main.c defs.h 转成： ​ main.o main.d : main.c defs.h 于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 [.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用 Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如： ​ sources = foo.c bar.c ​ include $(sources:.c=.d) 上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成 [.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标 4 Makefile 书写命令 -——————————————————————————- 每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。 我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。 4.1 显示命令 通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： ​ @echo 正在编译XXX模块…… 当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出： ​ echo 正在编译XXX模块…… ​ 正在编译XXX模块…… 如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 而make参数“-s”或“–slient”则是全面禁止命令的显示。 4.2 命令执行 当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如： ​ 示例一： ​ exec: ​ cd /home/hchen ​ pwd ​ 示例二： ​ exec: ​ cd /home/hchen; pwd 当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。 make 一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS- DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS- DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。 4.3 命令出错 每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。 有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。 为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： clean: ​ -rm -f *.o 还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。 还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。 4.4 嵌套执行make 在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。 例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写： ​ subsystem: ​ cd subdir &amp;&amp; $(MAKE) 其等价于： ​ subsystem: ​ $(MAKE) -C subdir 定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。 我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。 如果你要传递变量到下级Makefile中，那么你可以使用这样的声明： export 如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明： unexport 如： ​ 示例一： ​ export variable = value ​ 其等价于： ​ variable = value ​ export variable ​ 其等价于： ​ export variable := value ​ 其等价于： ​ variable := value ​ export variable ​ 示例二： ​ export variable += value ​ 其等价于： ​ variable += value ​ export variable 如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。 需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。 但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来： ​ subsystem: ​ cd subdir &amp;&amp; $(MAKE) MAKEFLAGS= 如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。 还有一个在“嵌套执行”中比较有用的参数，“-w”或是“–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到： ​ make: Entering directory `/home/hchen/gnu/make’. 而在完成下层make后离开目录时，我们会看到： ​ make: Leaving directory `/home/hchen/gnu/make’ 当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。 —++++4.5 定义命令包 如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如： ​ define run-yacc ​ yacc $(firstword $^) ​ mv y.tab.c $@ ​ endef 这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。 ​ foo.c : foo.y ​ $(run-yacc) 我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是 “foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。]]></content>
      <categories>
        <category>tutorial</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>Make</tag>
        <tag>MakeFile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何明确javascript中this的指代]]></title>
    <url>%2F2017%2F08%2F06%2Fhow-to-use-this-in-javascript%2F</url>
    <content type="text"><![CDATA[Javascript This在 Java 等面向对象的语言中，this 关键字的含义是明确且具体的，即指代当前对象。一般在编译期确定下来，或称为编译期绑定。而在 JavaScript 中，this 是动态绑定，或称为运行期绑定的，这就导致 JavaScript 中的 this 关键字有能力具备多重含义，带来灵活性的同时，也为初学者带来不少困惑。本文是作者对于一些关于此问题文章的总结归纳。 Java 语言中的 this在 Java 中定义类经常会使用 this 关键字，多数情况下是为了避免命名冲突，比如在下面例子的中，定义一个 Point 类，很自然的，大家会使用 x，y 为其属性或成员变量命名，在构造函数中，使用 x，y 为参数命名，相比其他的名字，比如 a，b，也更有意义。这时候就需要使用 this 来避免命名上的冲突。另一种情况是为了方便的调用其他构造函数，比如定义在 x 轴上的点，其 x 值默认为 0，使用时只要提供 y 值就可以了，我们可以为此定义一个只需传入一个参数的构造函数。无论哪种情况，this 的含义是一样的，均指当前对象。 public class Point { private int x = 0; private int y = 0; public Point(x, y){ this.x = x; this.y = y; } public Point(y){ this(0, y); } } Javascript 语言中的 this全局上下文无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this都指代全局对象。 // 在浏览器中, window 对象同时也是全局对象： console.log(this === window); // true a = 37; console.log(window.a); // 37 this.b = &quot;MDN&quot;; console.log(window.b) // &quot;MDN&quot; console.log(b) // &quot;MDN 函数上下文在函数内部，this的值取决于函数被调用的方式。 简单调用因为下面的代码不是在严格模式下执行，且this的值不是通过调用设置的，所以this的值默认指向全局对象。 function f1(){ return this; } //在浏览器中： f1() === window; //在浏览器中，全局对象是window //在Node中： f1() === global; 然而，在严格模式下，this将保持他进入执行上下文时的值，所以下面的this将会默认为undefined。 function f2(){ &quot;use strict&quot;; // 这里是严格模式 return this; } f2() === undefined; // true 所以，在严格模式下，如果this未在执行的上下文中定义，那它将会默认为undefined。在第二个例子中，this的确应该是undefined，因为f2是被直接调用的，而不是作为对象的属性或方法调用的（如 window.f2()）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误地返回了window对象。 如果要想把this的值从一个上下文传到另一个，就要用call，或者apply方法。 // 一个对象可以作为call和apply的第一个参数，并且this会被绑定到这个对象。 var obj = {a: &apos;Custom&apos;}; // 这个属性是在global对象定义的。 var a = &apos;Global&apos;; function whatsThis(arg) { return this.a; // this的值取决于函数的调用方式 } whatsThis(); // 直接调用， 返回&apos;Global&apos; whatsThis.call(obj); // 通过call调用， 返回&apos;Custom&apos; whatsThis.apply(obj); // 通过apply调用 ，返回&apos;Custom&apos; 在函数使用this关键字的情况下，它的值可以被绑定到调用中的一个特定对象，使用所有函数继承自Function.prototype的call或apply方法。 function add(c, d) { return this.a + this.b + c + d; } var o = {a: 1, b: 3}; // 第一个参数是作为‘this’使用的对象 // 后续参数作为参数传递给函数调用 add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16 // 第一个参数也是作为‘this’使用的对象 // 第二个参数是一个数组，数组里的元素用作函数调用中的参数 add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 使用 call 和 apply 函数的时候要注意，如果传递的 this 值不是一个对象，JavaScript 将尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 ‘foo’，那么就会使用相关构造函数将它转换为对象，所以原始值 7 通过new Number(7)被转换为对象，而字符串’foo’使用 new String(‘foo’) 转化为对象，例如： function bar() { console.log(Object.prototype.toString.call(this)); } //原始值 7 被隐式转换为对象 bar.call(7); // [object Number] bind方法ECMAScript 5 引入了 Function.prototype.bind。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。 function f(){ return this.a; } //this被固定到了传入的对象上 var g = f.bind({a:&quot;azerty&quot;}); console.log(g()); // azerty var h = g.bind({a:&apos;yoo&apos;}); //bind只生效一次！ console.log(h()); // azerty var o = {a:37, f:f, g:g, h:h}; console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty 箭头函数在箭头函数中，this与封闭词法上下文的this保持一致。在全局代码中，它将被设置为全局对象： var globalObject = this; var foo = (() =&gt; this); console.log(foo() === globalObject); // true 注意：如果将thisArg传递给call、bind、或者apply，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为null。 // 接着上面的代码 // 作为对象的一个方法调用 var obj = {foo: foo}; console.log(obj.foo() === globalObject); // true // 尝试使用call来设定this console.log(foo.call(obj) === globalObject); // true // 尝试使用bind来设定this foo = foo.bind(obj); console.log(foo() === globalObject); // true 无论如何，foo的this被设置为它被创建时的上下文（在上面的例子中，就是全局对象）。这同样适用于在其他函数中创建的箭头函数：这些箭头函数的this被设置为外层执行上下文。 // 创建一个含有bar方法的obj对象，bar返回一个函数，这个函数返回它自己的this， // 这个返回的函数是以箭头函数创建的，所以它的this被永久绑定到了它外层函数的this。 // bar的值可以在调用中设置，它反过来又设置返回函数的值。 var obj = {bar: function() { var x = (() =&gt; this); return x; } }; // 作为obj对象的一个方法来调用bar，把它的this绑定到obj。 // x所指向的匿名函数赋值给fn。 var fn = obj.bar(); // 直接调用fn而不设置this，通常(即不使用箭头函数的情况)默认为全局对象，若在严格模式则为undefined console.log(fn() === obj); // true // 但是注意，如果你只是引用obj的方法，而没有调用它(this是在函数调用过程中设置的) var fn2 = obj.bar; // 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。 console.log(fn2()() == window); // true 在上面的例子中，一个赋值给了 obj.bar的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，函数B的this被永久设置为obj.bar（函数A）被调用时的this。当返回的函数（函数B）被调用时，它this始终是最初设置的。在上面的代码示例中，函数B的this被设置为函数A的this，即obj，所以它仍然设置为obj，即使以通常将this设置为undefined或全局对象（或者如前面示例中全局执行上下文中的任何其他方法）进行调用。 作为对象的方法当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象.下面的例子中，当 o.f()被调用时，函数内的this将绑定到o对象。 var o = { prop: 37, f: function() { return this.prop; } }; console.log(o.f()); // logs 37 请注意，这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象o的同时，将成员f定义了一个匿名函数。但是，我们也可以首先定义函数，然后再将其附属到o.f。这样做会导致相同的行为： var o = {prop: 37}; function independent() { return this.prop; } o.f = independent; console.log(o.f()); // logs 37 这表明只有函数是从o的f成员调用才有意义。 类似的，this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法g当作对象o.b的函数调用。在这次执行期间，函数中的this将指向o.b。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。 o.b = {g: independent, prop: 42}; console.log(o.b.g()); // 42 原型链中的 this相同的概念在定义在原型链中的方法也是一致的。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就好像该方法本来就存在于这个对象上。 var o = { f : function(){ return this.a + this.b; } }; var p = Object.create(o); p.a = 1; p.b = 4; console.log(p.f()); // 5 在这个例子中，对象p没有属于它自己的f属性，它的f属性继承自它的原型。但是这对于最终在o中找到f属性的查找过程来说没有关系；查找过程首先从p.f的引用开始，所以函数中的this指向p。也就是说，因为f是作为p的方法调用的，所以它的this指向了p。这是 JavaScript 的原型继承中的一个有趣的特性。 getter 与 setter 中的 this再次，相同的概念也适用时的函数作为一个 getter 或者 一个 setter 调用。用作getter或setter的函数都会把 this 绑定到正在设置或获取属性的对象。 function sum() { return this.a + this.b + this.c; } var o = { a: 1, b: 2, c: 3, get average() { return (this.a + this.b + this.c) / 3; } }; Object.defineProperty(o, &apos;sum&apos;, { get: sum, enumerable: true, configurable: true}); console.log(o.average, o.sum); // logs 2, 6 作为构造函数当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。 /* * 构造函数这样工作: * * function MyConstructor(){ * // 函数实体写在这里 * // 根据需要在this上创建属性，然后赋值给它们，比如： * this.fum = &quot;nom&quot;; * // 等等... * * // 如果函数具有返回对象的return语句，则该对象将是 new 表达式的结果。 * // 否则，表达式的结果是当前绑定到 this 的对象。 * //（即通常看到的常见情况）。 * } */ function C(){ this.a = 37; } var o = new C(); console.log(o.a); // logs 37 function C2(){ this.a = 37; return {a:38}; } o = new C2(); console.log(o.a); // logs 38 在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与this绑定的默认对象被丢弃了。（这基本上使得语句 “this.a = 37;”成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。 参考文献 Understanding JavaScript Function Invocation and “this” 深入浅出 JavaScript 中的 this javascript教程]]></content>
      <categories>
        <category>tutorial</category>
        <category>javascript</category>
        <category>key word-this</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[programming-languages-convention]]></title>
    <url>%2F2017%2F07%2F06%2Fprogramming-languages-convention%2F</url>
    <content type="text"><![CDATA[本篇文章记录了一些语言的命名习惯，仅供参考。 命名规则 不同的代码段采用不同的命名长度。通常来说，循环计数器（loop counters）采用1位的单字符来命名，循环判断变量（condition/loop variables）采用1个单词来命名，方法采用1-2个单词命名，类采用2-3个单词命名，全局变量采用3-4个单词命名。 对变量采用具体的命名（specific names）方式，”value”, “equals”, “data”在任何情况下都不是一种有效的命名方式。 采用有意义的命名（meaningful names）。变量的名字必须准确反映它的含义和内容。 不要用 o, obj, m_ 等前缀命名。变量不需要前缀标签来表示自己是一个变量。 遵循公司的变量命名规则，在项目中坚持使用同一种变量命名方式。例如txtUserName, lblUserName, cmbSchoolType等，否则会对可读性造成影响，而且会令查找/替换工具（find/replace tools）不可用。 遵循当前语言的变量命名规则，不要不统一（inconsistently）地使用大/小写字母。例如：userName, UserName, USER_NAME, m_userName, username, …。以Java为例: 类名使用驼峰命名法（Camel Case）：VelocityResponseWriter 包名使用小写：com.company.project.ui 变量使用首字母小写的驼峰命名法（Mixed Case）：studentName 常量使用大写:MAX_PARAMETER_COUNT = 100 枚举类（enum class）采用驼峰命名法，枚举值（enum values）采用大写。 除了常量和枚举值以外，不要使用下划线’_’ 在同一个类不同的场景（contexts）中不要复用变量名。例如在方法、初始化方法和类中。这样做可以提高可读性和可维护性。 不要对不同使用目的的变量使用同一个变量名，而是赋予它们不同的名字。这同样对保持可读性和可维护性很重要。 变量名不要使用非ASCII字符（non-ASCII chars）。这样做可能会在跨平台使用时产生问题。 不要使用过长的变量名（例如50个字符）。过长的变量名会导致代码丑陋（ugly）和难以阅读（hard-to-read），还可能因为字符限制在某些编译器上存在兼容性问题。 仅使用一种自然语言（natural language）来命名变量。例如，同时使用德语和英语来命名变量会导致（理解）不一致和降低可读性。 使用有意义的方法名。方法名必须准确表达该方法的行为，在多数情况下以动词（verb）开头。（例如：createPasswordHash） 遵循公司的方法命名规则，在项目中坚持使用同一种方法命名方式。例如 getTxtUserName(), getLblUserName(), isStudentApproved()，否则会对可读性造成影响，而且会令查找/替换工具不可用。 遵循当前语言的变量命名规则，不要不统一地使用大/小写字母。例如：getUserName, GetUserName, getusername, …。以Java为例: 方法使用首字母小写的驼峰命名法：getStudentSchoolType 方法参数使用首字母小写的驼峰命名法：setSchoolName(String schoolName) 使用有意义的方法参数命名，这样做可以在没有文档的情况下尽量做到“自解释（documentate itself）” PythonGoogle Python Style Guide has the following convention: module_name, package_name, ClassName, method_name, ExceptionName function_name, GLOBAL_CONSTANT_NAME, global_var_name instance_var_name, function_parameter_name, local_var_name 主要使用下划线，只有类名和Exception使用UpperCamelCase这种形式。Google Python Style Guide JavaClass names are written in UpperCamelCase.Method names are written in lowerCamelCase.Constant names use CONSTANT_CASE.大部分命名主要使用UpperCamelCase这种形式，只有常量才使用下划线。 JavaScriptThe built-in JavaScript libraries use the same naming conventions as Java. Data types and constructor functions use upper camel case (RegExp, TypeError, XMLHttpRequest, DOMObject) and methods use lower camel case (getElementById, getElementsByTagNameNS, createCDATASection). In order to be consistent most JavaScript developers follow these conventions.[citation needed] See also: Douglas Crockford’s conventions和Java的命名规则相同。 .NETMicrosoft .NET recommends UpperCamelCase for most identifiers. (lowerCamelCase is recommended for parameters and variables) and is a shared convention for the .NET languages. Microsoft further recommends that no type prefix hints (also known as Hungarian notation) are used. Instead of using Hungarian notation it is recommended to end the name with the base class’ name; LoginButton instead of BtnLogin. SwiftSwift has shifted its naming conventions with each individual release. However a major update with Swift 3.0 stabilised the naming conventions for lowerCamelCase across variables and function declarations. Constants are usually defined by enum types or constant parameters that are also written this way. Class and other object type declarations are UpperCamelCase. ReferenceWikipedia) google/styleguide 15 Best Practices of Variable &amp; Method Naming]]></content>
      <categories>
        <category>tutorial</category>
        <category>program language convention</category>
      </categories>
      <tags>
        <tag>convention</tag>
        <tag>programming languages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jekyll搭建静态博客]]></title>
    <url>%2F2017%2F02%2F21%2Fbuild-blog-by-jekyll%2F</url>
    <content type="text"><![CDATA[根据本教程内容可以建立一个基于jekyll和github pages的静态博客网站，但是作者本人比较推荐使用hexo和github pages去建立静态博客网站。两者在功能上区别不大，但是hexo更加简洁方便，能够很快的实现，因此推荐使用。 安装Jekyll在安装jekyll之前，需要先安装ruby和rubyRem。而在安装ruby和rubyRem之前，可以先安装RVM（一个管理ruby版本的东西），当然也可以直接安装ruby。MAC 系统本身自带ruby， 但是版本比较旧。 我的电脑是MAC，所以以下是MAC的安装过程，linux或者windows可以去安装RVM教程网站上查看。 因为我不太想让ruby的不同版本都出现在我的电脑上，所以打算先安装一个RVM，ruby版本管理工具。 For MAC: 12345$ curl -L https://get.rvm.io | bash -s stable //安装RVM$ source ~/.rvm/scripts/rvm // 载入RVM环境 $ rvm -v // 显示版本 1234567$ rvm list known // 列出可以安装的ruby版本$ rvm install 2.4.2 // 安装某个版本$ rvm list //列出已经安装的版本$ rvm remove 1.9.2 //删除某个版本 For Linux: Linux安装RVM比较麻烦，建议直接安装ruby，可以参考官方教程安装ruby教程。 1$ sudo apt-get install ruby-full 安装rubygems 1$ sudo apt-get install rubygems 安装jekyll 1$ sudo gem install jekyll 成功安装jekyll以后，可以选择进入一个目录，运行 1$ jekyll new [websiteName] 就可以自动建立一个可以使用的jekyll项目了。 使用apt-get安装一些dependencies，像是bundle和minima。也可以用bundle install命令安装gemfile所写的一些dependencies。安装之后就可以成功build和运行了，运行使用的是jekyll serve命令，可以在localhose:4000看到网页的样子。如果成功看到网页，就完成了一个简单的博客了。 使用jekylljekyll自带的模版样子比较丑，想要好看的模版需要从网上下载。也可以参考官方文档或者中文文档来学习jekyll的基本使用。 对于没有时间深入研究并且对于博客的个性化没有太高的要求的同学来说，只是想搭一个能用的blog的话，可以从网上搜索别人设计好的模版，比如我所使用的Jacman模版。当然，也可以自己从jekyll的网站下载想用的模版，不过在下载好模版以后，还需要对于模版进行一些修改和一些配置。 模版的使用在Jacman模版的_post文件夹（也就是存放博客文件的目录）里有全部作者对于各类标签的使用方式和对于元素显示的测试，我都将其放入了draft（也就是存放草稿的目录）下。 以下简单总结一下标签的使用，至于内容编写的格式可以参考任意的Markdown教程。我使用的MD编辑器是Macdown，Macdown可以编写的同时查看MD生成的样式，而且免费，大家也可以使用自己喜欢的MD编辑器。 种类标签注意，标签不可为中文，不然会有错误。 123456789Categories:- Foo- Bar- Baztags:- Foo- Bar- Baz 名称，日期和图片1234title: 文章名称date: 2016-12-25 00:23:23image: http://...pngdescription: 其他描述 照片123photos:- http://ww1.sinaimg.cn/mw690/81b78497jw1emfgwkasznj21hc0u0qb7.jpg- http://ww3.sinaimg.cn/mw690/81b78497jw1emfgwjrh2pj21hc0u01g3.jpg]]></content>
      <categories>
        <category>tutorial</category>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>tutorial</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
        <tag>hero</tag>
        <tag>firstpost</tag>
      </tags>
  </entry>
</search>
